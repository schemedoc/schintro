<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.45
     from schintro.txi on 19 Febuary 1997 -->

<TITLE>An Introduction to Scheme and its Implementation - Macros</TITLE>
</HEAD>
<BODY>
Go to the <A HREF="schintro_1.html">first</A>, <A HREF="schintro_73.html">previous</A>, <A HREF="schintro_75.html">next</A>, <A HREF="schintro_143.html">last</A> section, <A HREF="schintro_toc.html">table of contents</A>.
<HR>


<H2><A NAME="SEC81" HREF="schintro_toc.html#SEC81">Macros</A></H2>

<P>
<A NAME="IDX86"></A>

</P>
<P>
Scheme is very procedure-oriented, but procedures can't do everything,
at least not in a way that is syntactically pretty and efficient.

</P>
<P>
Sometimes you want to define your own control structures and data-defining
expressions that can't be clearly and efficiently expressed as procedures,
and for this Scheme provides a <EM>syntactic extension</EM> or <EM>macro</EM>
facility.

</P>
<P>
With <EM>macros</EM>, you can define stereotyped pieces of code, and how
to transform them for different purposes.

</P>
<P>
You might have had bad experiences with macros in other languages,
like C, but Scheme's macro system is special.  It's an extremely
powerful mechanism for abstracting over programs and putting things
together in special ways.

</P>
<P>
As we'll see in a later chapter, with Scheme macros you can effectively 
reprogram the compiler to change the language and its implementation.
This is not something you'll need to do often--most of the time you'll
do fine with normal programming and higher-order procedures--but sometimes
it's extremely useful for building your own extended version of Scheme
to solve particular kinds of problems, or for automating tedious and
repetitive aspects of program construction.

</P>

<HR>
Go to the <A HREF="schintro_1.html">first</A>, <A HREF="schintro_73.html">previous</A>, <A HREF="schintro_75.html">next</A>, <A HREF="schintro_143.html">last</A> section, <A HREF="schintro_toc.html">table of contents</A>.
</BODY>
</HTML>
